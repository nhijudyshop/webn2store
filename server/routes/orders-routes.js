const express = require("express");
const fs = require("fs");
const { supabase } = require("../integrations/supabase/client");
const { ORDERS_FILE } = require("../config");

const router = express.Router();

// --- ONE-TIME MIGRATION LOGIC ---
let migrationAttempted = false;
async function migrateOrdersToSupabase() {
    if (migrationAttempted) return;
    migrationAttempted = true;

    try {
        console.log("Checking if orders migration is needed...");

        const { count, error: countError } = await supabase
            .from('orders')
            .select('*', { count: 'exact', head: true });

        if (countError) {
            console.error("‚ùå Supabase count error:", countError.message);
            return;
        }

        if (!fs.existsSync(ORDERS_FILE)) {
            console.log("‚è≠Ô∏è JSON file not found, skipping migration.");
            return;
        }
        const jsonData = fs.readFileSync(ORDERS_FILE, "utf8");
        const oldOrders = JSON.parse(jsonData);

        if (oldOrders.length === 0) {
            console.log("‚è≠Ô∏è JSON file is empty, skipping migration.");
            fs.renameSync(ORDERS_FILE, `${ORDERS_FILE}.migrated`);
            return;
        }
        
        if (count === 0 && oldOrders.length > 0) {
            console.log(`üöö Migrating ${oldOrders.length} orders from JSON to Supabase...`);

            const ordersToInsert = oldOrders.map(order => {
                // Map camelCase from JSON to snake_case for Supabase
                const newOrder = {
                    raw_date: order.rawDate ? new Date(order.rawDate).toISOString() : null,
                    supplier: order.supplier,
                    total_qty: order.totalQty,
                    invoice: order.invoice,
                    invoice_image_url: order.invoiceImageUrl,
                    product_name: order.productName,
                    product_code: order.productCode,
                    variant: order.variant,
                    quantity: order.quantity,
                    purchase_price: order.purchasePrice,
                    sale_price: order.salePrice,
                    note: order.note,
                    status: order.status,
                    product_image_url: order.productImageUrl,
                    purchase_price_image_url: order.purchasePriceImageUrl,
                    // id and created_at will be auto-generated by Supabase
                };
                return newOrder;
            });

            const { error: insertError } = await supabase
                .from('orders')
                .insert(ordersToInsert);

            if (insertError) {
                console.error("‚ùå Migration insert error:", insertError.message);
            } else {
                console.log("‚úÖ Migration successful!");
                fs.renameSync(ORDERS_FILE, `${ORDERS_FILE}.migrated`);
                console.log(`üì¶ Renamed old orders file to ${ORDERS_FILE}.migrated`);
            }
        } else {
            console.log(`‚è≠Ô∏è Skipping migration. Supabase orders: ${count}, JSON orders: ${oldOrders.length}.`);
            if (fs.existsSync(ORDERS_FILE)) {
                 fs.renameSync(ORDERS_FILE, `${ORDERS_FILE}.migrated`);
                 console.log(`üì¶ Renamed old orders file to ${ORDERS_FILE}.migrated to prevent conflicts.`);
            }
        }
    } catch (error) {
        console.error("‚ùå An error occurred during the migration check:", error.message);
    }
}
// --- END OF MIGRATION LOGIC ---

// Get all orders
router.get("/orders", async (req, res) => {
    if (!migrationAttempted) {
        await migrateOrdersToSupabase();
    }

    try {
        const { data, error } = await supabase
            .from('orders')
            .select('*')
            .order('raw_date', { ascending: false });

        if (error) throw error;

        // Map snake_case from Supabase to camelCase for frontend
        const formattedData = data.map(order => ({
            id: order.id,
            date: new Date(order.raw_date).toLocaleDateString('vi-VN'), // Reconstruct date for frontend
            time: new Date(order.raw_date).toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' }), // Reconstruct time
            rawDate: order.raw_date, // Keep rawDate for sorting
            supplier: order.supplier,
            totalQty: order.total_qty,
            invoice: order.invoice,
            invoiceImageUrl: order.invoice_image_url,
            productName: order.product_name,
            productCode: order.product_code,
            variant: order.variant,
            quantity: order.quantity,
            purchasePrice: order.purchase_price,
            salePrice: order.sale_price,
            note: order.note,
            status: order.status,
            productImageUrl: order.product_image_url,
            purchasePriceImageUrl: order.purchase_price_image_url,
            createdAt: order.created_at,
        }));

        res.json({ success: true, data: formattedData });
    } catch (error) {
        console.error("‚ùå Error reading orders from Supabase:", error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Add new orders
router.post("/orders", async (req, res) => {
    try {
        const newOrders = req.body;
        if (!Array.isArray(newOrders)) {
            return res.status(400).json({ success: false, error: "Request body must be an array of orders." });
        }

        const ordersToInsert = newOrders.map(order => {
            // Map camelCase from request body to snake_case for Supabase
            const newOrder = {
                raw_date: order.rawDate,
                supplier: order.supplier,
                total_qty: order.totalQty,
                invoice: order.invoice,
                invoice_image_url: order.invoiceImageUrl,
                product_name: order.productName,
                product_code: order.productCode,
                variant: order.variant,
                quantity: order.quantity,
                purchase_price: order.purchasePrice,
                sale_price: order.salePrice,
                note: order.note,
                status: order.status,
                product_image_url: order.productImageUrl,
                purchase_price_image_url: order.purchasePriceImageUrl,
            };
            return newOrder;
        });

        const { data, error } = await supabase
            .from('orders')
            .insert(ordersToInsert)
            .select();

        if (error) throw error;

        console.log(`‚úÖ ${data.length} new order(s) saved successfully to Supabase.`);
        res.json({ success: true, message: "Orders saved successfully" });
    } catch (error) {
        console.error("‚ùå Error saving orders to Supabase:", error);
        res.status(500).json({ success: false, error: error.message });
    }
});

// Delete an order
router.delete("/orders/:id", async (req, res) => {
    try {
        const orderIdToDelete = req.params.id;

        const { error } = await supabase
            .from('orders')
            .delete()
            .match({ id: orderIdToDelete });

        if (error) throw error;

        console.log(`üóëÔ∏è Order with ID ${orderIdToDelete} deleted successfully from Supabase.`);
        res.json({ success: true, message: "Order deleted successfully" });
    } catch (error) {
        console.error(`‚ùå Error deleting order with ID ${req.params.id} from Supabase:`, error);
        res.status(500).json({ success: false, error: error.message });
    }
});

module.exports = router;